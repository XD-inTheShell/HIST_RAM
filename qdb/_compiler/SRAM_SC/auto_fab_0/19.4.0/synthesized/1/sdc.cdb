22 serialization::archive 13 0 0 0 0 4 0 1 / 4 home 7 xiyingd 16 HIST_RAM_MEMTEST 0 0 2 0 0 0 11 0 1 / 4 home 8 Programs 13 intelFPGA_pro 4 19.4 2 ip 6 altera 3 sld 4 jtag 20 altera_jtag_wys_atom 16 default_jtag.sdc 4150 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# This SDC is used to constrain a design containing logic driven by JTAG that is missing a clocking
# constraint on altera_reserved_tck. This SDC will add a default constraint if none is present, and 
# there are is at least one clock defined in the design.  We don't want to constrain altera_reserved_tck
# when there are no defined clocks since altera_reserved_tck will then become the highest priority clock.
# This will affect the place and route result of logic driven by other clocks in the design.

namespace eval intel_reserved_jtag_default_constraints {

    proc set_default_quartus_fit_timing_directive { } {
        # A10 & S10 support max 33.3Mhz clock
        set jtag_33Mhz_t_period 30
        
        create_clock -name {altera_reserved_tck} -period $jtag_33Mhz_t_period [get_ports {altera_reserved_tck}] 
        set_clock_groups -asynchronous -group {altera_reserved_tck} 
        # Force fitter to place register driving TDO pin to be as close to 
        # the JTAG controller as possible to maximize the slack outside of FPGA.
        if {$::TimeQuestInfo(family) == "Arria 10"} {
            set_max_delay -to [get_ports { altera_reserved_tdo } ] 0
        }
        
        # Declare false-paths for S10 JTAG Atom ( see HSD-ES:1408819417 )
        if {$::TimeQuestInfo(family) == "Stratix 10"} {
            set_false_path -from "*|atom_inst|atom~soc_sdm/padsig_io1.reg"
            set_false_path -from "*|atom_inst|atom~soc_sdm/padsig_io1.reg__nff"
        }
        
        # Set pessimistic input delays to properly establish timing relationship between tck and tms, tdi
        set input_delay_period 0.5
        set_input_delay -max -clock_fall -clock [get_clocks altera_reserved_tck] $input_delay_period [get_ports altera_reserved_tms]
        set_input_delay -min -clock_fall -clock [get_clocks altera_reserved_tck] [expr {0 - $input_delay_period}] [get_ports altera_reserved_tms]    
        set_input_delay -max -clock_fall -clock [get_clocks altera_reserved_tck] $input_delay_period [get_ports altera_reserved_tdi]
        set_input_delay -min -clock_fall -clock [get_clocks altera_reserved_tck] [expr {0 - $input_delay_period}] [get_ports altera_reserved_tdi]
    }

    proc add_contraints_if_appropriate { } {
        # Only constrain if the design contains user-declared clocks
        set number_of_user_clocks [get_collection_size [all_clocks]]

        if {$number_of_user_clocks > 0} {
            # Only constrain if altera_reserved_tck has not already been constrained
            set tck_declared [get_collection_size [get_clocks -nowarn altera_reserved_tck]]
            if {$tck_declared == 0 || ![is_clock_defined altera_reserved_tck]} {
                post_message -type info "Adding default timing constraints to JTAG signals.  This will help to achieve basic functionality since no such constraints were provided by the user."
                set_default_quartus_fit_timing_directive
            }
        }
    }
}

# Only make these constraints for the fitter as they are hints, not suitable for timing sign-off
if { [string equal quartus_fit $::TimeQuestInfo(nameofexecutable)] } {
    # Define a different set of timing spec to influence place-and-route 
    # result in the jtag clock domain. The slacks outside of FPGA are 
    # maximized.
    intel_reserved_jtag_default_constraints::add_contraints_if_appropriate
} 19 0 1 / 4 home 7 xiyingd 16 HIST_RAM_MEMTEST 3 qdb 9 _compiler 7 SRAM_SC 5 _flat 6 19.4.0 11 partitioned 1 1 5 .temp 11 sld_fabrics 5 ipgen 13 alt_sld_fab_0 13 alt_sld_fab_0 26 altera_signaltap_agent_191 5 synth 20 intel_signal_tap.sdc 5246 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# $Revision: #1 
# $Date: 2017/07/31 
# $Author: zkumar 

#-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to between stp_status_bits_in_reg (acq domain) and stp_status_bits_out (tck domain)
# 
# CDC takes place between these paths (in intel_stp_status_bits_cdc component)
#

# -----------------------------------------------------------------------------
# This procedure constrains the max_delay (not skew) between the status bit regs.
#
# The hierarchy path to the status_bits CDC instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_signaltap_status_bits_max_delay { path } {

    #set the to/from paths for stp_status_bits
    set path_from $path|stp_status_bits_in_reg\[*\]
    set path_to $path|stp_status_bits_out\[*\]

    #check if the paths to be constrained exist or not
    set num_status_paths_from 0
    set num_status_paths_to 0
    foreach_in_collection status_bits_from_fanout [get_fanouts $path_from] { incr num_status_paths_from }
    foreach_in_collection status_bits_to_fanout [get_fanouts $path_to] { incr num_status_paths_to }
    ##post_message -type info "DEBUG: paths detected for *stp_status_bits_in* = $num_status_paths_from"
    ##post_message -type info "DEBUG: paths detected for *stp_status_bit_out* = $num_status_paths_to"

    #if either "to" or "from" paths donot exist, exit the .sdc gracefully
    if {$num_status_paths_from == 0 || $num_status_paths_to == 0} {
    
        post_message -type info "stp_status_bits_in*, stp_status_bits_out* or both synthesized out, max delay will not be set in this instance of intel_stp_status_bits_cdc"
        
    } else {
    
        post_message -type info "stp_status_bits_in*, stp_status_bits_out* paths exist in this instance of intel_stp_status_bits_cdc"
        #call to function to get the tck domain name and period
        ##puts "DEBUG: my path = $path|stp_status_bits_out*"
        set max_delay_prd [expr [get_tck_info $path|stp_status_bits_out*]]
        ##puts "DEBUG: max delay is 1xtck_clk_prd = $max_delay_prd"

        #set the max delay as function of dst clk period (i.e. tck clk prd) so that -
        #1) to make the delay settings more relaxed (more than 1ns), between i/p and o/p status bits 
        #2) to ensure the max delay can be used when acq clk > tck clk and vice-versa
        #max delay is 1xtck clk period (because valid bit takes ~3 cycles to go from acq to tck domain)

        set_max_delay -from [ get_registers $path_from ] -to [ get_registers $path_to ] $max_delay_prd
    
    }  

}

# -----------------------------------------------------------------------------
# This procedure is to find out the tck clk name and period
#
# The hierarchy path to the status_bits CDC instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc get_tck_info { filter } {
    ##puts "DEBUG: Search for $filter"
    set my_tck_clk [get_fanins $filter -clock]
    ##puts "DEBUG: my_tck_clk = $my_tck_clk"

    # A10 & S10 support max 33.3Mhz clock (default, in case tck clk prd is not defined)
    set default_tck_prd 30
    
    foreach_in_collection clk $my_tck_clk {
        set tck_clk_node_name [get_node_info -name $clk]
        ##puts "DEBUG: tck domain clk name: $tck_clk_node_name"

        ##check if tck clk period has been previously declared or not
        set tck_declared [get_collection_size [get_clocks -nowarn $tck_clk_node_name]]
        if {$tck_declared == 0 || ![is_clock_defined $tck_clk_node_name]} {
                ##puts "DEBUG: tck clk period is not defined, setting max delay to 30ns (default 33MHz tck)"
                post_message -type info "tck clk period is not defined, setting max delay to 30ns (default 33MHz tck)"
                set tck_clk_prd $default_tck_prd
                ##puts "DEBUG: tck domain period (default): $tck_clk_prd"
        } else {
               set tck_clk_prd [get_clock_info $tck_clk_node_name -period]
               ##puts "DEBUG: tck domain period: $tck_clk_prd"  
        }        

       
    }

    return $tck_clk_prd

}


constrain_signaltap_status_bits_max_delay "[get_current_instance]|sld_signaltap_inst|sld_signaltap_body|sld_signaltap_body|jtag_acq_clk_xing|intel_stp_status_bits_cdc_u1"
 0
